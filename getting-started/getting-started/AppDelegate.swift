//
//  AppDelegate.swift
//  getting-started with push notifications via APNs
//  getting-started created by Craig Lane on 1/13/22.
//

import UIKit
import PubNub
import UserNotifications

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    
    let pubNub = PubNubConnection.shared //Shared PubNub connection object.
    let pushChannels: [String] = ["Default", "ch1"]
    
    // Override point for customization after application launch.
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        UNUserNotificationCenter.current().delegate = self //Need to assign delegate object before app finishes launching. Might miss incoming notifications otherwise.
        //Requires user authorization before displaying notifications on device.
        UNUserNotificationCenter.current().requestAuthorization(options: [.badge, .alert, .sound]) { (granted, err) in
            guard granted else {return} //Do not continue if not authorized.
            DispatchQueue.main.async() {
              UIApplication.shared.registerForRemoteNotifications() //Request device token.
            }
        }
        return true
    }

    // MARK: UISceneSession Lifecycle
    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
    // Called when a new scene session is being created.
    // Use this method to select a configuration to create the new scene with.
    return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }
    
    //Handle Silent Push Notification. Used to notify application when new content becomes available without needing to alert user.
    func application( _ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any],
                      fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
        /*
         1. Enable Remote Notifications Capability via App -> Targets -> Signing & Capability -> Add Background Modes capability, then select Remote notification checkbox.
         2. Create remote notification that includes only the content-available key, "content-available" : 1. Do not include any keys that would trigger user interactions.
         3. Receive background notification by having the system wake your app in background and calls this handler to silently handle notification.
         */
    }

    //Successfully registered and received device token from APNs. Register device on PubNub network.
    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        addDevice(deviceToken: deviceToken) //Registers device token on PubNub network.
    }
    
    //Failed to register and receive a device token from APNs.
    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
        print("Failed to register: \(error)")
    }
    
    //Adds the given device token to a list of channels on the PubNub network.
    func addDevice(deviceToken: Data) {
        pubNub.addAPNSDevicesOnChannels(
            pushChannels, //list of channels.
            device: deviceToken, //device token generated by APNs
            on: Bundle.main.bundleIdentifier!, //the topic, which is the bundle ID of the project
            environment: .development //environment, either production or development based on token type generated in Apple Dev Program account.
          ) { result in
            switch result {
            case let .success(channelsAdded):
                print("Device successfully added to the following channels:\(dump(channelsAdded))")
            case let .failure(error):
                print("Failed to add device \(deviceToken.description): \(error.localizedDescription)")
            }
          }
    }
    
    //List the channels the device is registered in on the PubNub Network.
    func listChannels(deviceToken: Data) -> [String] {
        var registeredChannels: [String] = []
        pubNub.listAPNSPushChannelRegistrations(
          for: deviceToken,
          on: Bundle.main.bundleIdentifier!,
          environment: .development
        ) { result in
          switch result {
          case let .success(channelsRegistered):
              print("Successully found channels for device: \(dump(channelsRegistered))")
              registeredChannels = channelsRegistered
          case let .failure(error):
              print("Failed to find the device on channels: \(error.localizedDescription)")
          }
        }
        
        return registeredChannels
    }
    
    //Remove the device from the channels in the PubNub network.
    func removeDevice(deviceToken: Data, channels: [String]) {
        pubNub.removeAPNSDevicesOnChannels(
            channels,
            device: deviceToken,
            on: Bundle.main.bundleIdentifier!,
            environment: .development
          ) { result in
            switch result {
            case let .success(channelsRemoved):
                print("Successully removed the device from the following channels: \(dump(channelsRemoved))")
            case let .failure(error):
                print("Failed to remove the device from the channels: \(error.localizedDescription)")
            }
          }
    }
}

//Handle a notification that arrived while the app was running in the foreground.
extension AppDelegate: UNUserNotificationCenterDelegate {
    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler(.alert)
    }
}
